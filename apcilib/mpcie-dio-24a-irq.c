#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <linux/types.h>
#include <unistd.h>
#include <signal.h>
#include <pthread.h>

#include "apcilib.h"
#include "kbhit.inc"

#define BAR_REGISTER 1

int fd;
pthread_t worker_thread;
int terminated = 0;

void * worker(void *arg)
{
    int status;
    __u32 inputData = 0;
    do {
        status = apci_wait_for_irq(fd, 1);
        if (0 == status)
        {
            apci_write8(fd, 1, BAR_REGISTER, 0x29, 0xFF);
            apci_read32(fd, 1, BAR_REGISTER, 0x30, &inputData);
            printf("CoS IRQ Generated by = %06X\n", inputData);
        }
        else
        {
            if (terminated)
                printf("User canceled, aborting worker thread.\n");
            else
                printf("unrecognized error occurred, aborting worker thread.\n");
        }
    } while (!terminated);
}

void abort_handler(int s){
  printf("Caught signal %d\nAborting.\n",s);

  terminated = 1;
  apci_cancel_irq(fd, 1);
  pthread_join(worker_thread, NULL);
  close(fd);
  exit(1);
}

int main (int argc, char **argv)
{
    signal(SIGINT, &abort_handler);

    printf("DIO & CoS IRQ sample for mPCIe-DIO-24A\nPlease disconnect anything sensitive to output changes and press any key.\n");
    do {} while (!kbhit()); // wait for keystroke
    tcflush(0, TCIFLUSH);
    time_t the_time;
    int status = 0;
    __u8 inputData;

#define deviceFileName "/dev/apci/mpcie_dio_24a_0"

    fd = open(deviceFileName, O_RDONLY);

    if (fd < 0)
    {
        printf("Device file %s could not be opened. Please ensure device filname and permissions ('sudo?') and that apci.ko is insmod.\n", deviceFileName);
        exit(0);
    }
    apci_write8(fd,1,BAR_REGISTER, 0xFC,0x04);// BOARD RESET
    printf("Changing Port A to OUTPUT.\n");
    apci_write8(fd, 1, BAR_REGISTER, 3, 0b10011001);
    for (int bit = 0; bit < 8; ++bit)
    {
        apci_write32(fd, 1, BAR_REGISTER, (bit+1) * 0x100 + 0x4, 0x0000009F); // enable rising and falling edge Events on bit 0
        apci_write32(fd, 1, BAR_REGISTER, (bit+1) * 0x100 + 0xC, 1); // generate an IRQ on *each* event
    }
    apci_write32(fd, 1, BAR_REGISTER, 0x30, 0x000000FF); // mask Port A CoS IRQ feature; it is an output
    apci_write32(fd, 1, BAR_REGISTER, 0x40, 0x00FFFFFF); // clear any pending Event IRQs
    apci_write8(fd, 1, 0, 0x69, 0x80); // enable PEX8311 IRQ just in case

    apci_write8(fd, 1, BAR_REGISTER, 0x0B, 0x00); // unmask all CoS IRQ sources just in case
    apci_write8(fd, 1, BAR_REGISTER, 0x0F, 0xFF); // clear IRQ latch just in case
    apci_write8(fd, 1, BAR_REGISTER, 0x29, 0xFF); // clear IRQ latch like C# sample does
    apci_write8(fd, 1, BAR_REGISTER, 0x28, 0xFF); // global enable the IRQ like C# sample does
    apci_write8(fd, 1, BAR_REGISTER, 0x29, 0xFF); // clear IRQ latch like C# sample does just in case

    printf("Testing CoS IRQ on A&C while toggling port B bits.  Press any key to stop waiting.\nWaiting for irq @ %s:\n", ctime(&the_time));

    __u8 pattern = 1;
    do // wait for IRQ
    {
		apci_write8(fd, 1, BAR_REGISTER, 1, pattern); // write data to output bits 8-15
        pattern <<= 1;
        if (pattern == 0)
            pattern = 1;
        usleep(10); // IRQ or TWO should have occurred
        __u8 valueB;
        __u32 value30, value40;
        apci_read8(fd, 1, BAR_REGISTER, 0, &valueB);
        apci_read32(fd, 1, BAR_REGISTER, 0x30, &value30);
        apci_read32(fd, 1, BAR_REGISTER, 0x40, &value40);

        printf("Wrote %02hhX to bits 8-15, read %02hhX on bits 0-7, Events Enabled: %06X Events generated: %06x\n",pattern, valueB, value30, value40);
        printf("ecnt:");
        for (int bit = 0; bit < 24; bit++)
        {
            __u32 value;
            apci_read32(fd, 1, BAR_REGISTER, (bit+1) * 0x100 + 8, &value);
            printf("%02x ",value);
        }
        printf("\n");
        printf(" cnt:");
        for (int bit = 0; bit < 24; bit++)
        {
            __u32 value;
            apci_read32(fd, 1, BAR_REGISTER, (bit+1) * 0x100 + 0x0C, &value);
            printf("%02x ",value);
        }
        printf("\n");
        usleep(100000);
    } while (!kbhit());

    tcflush(0, TCIFLUSH);


    apci_read8(fd, 1, BAR_REGISTER, 0, &inputData);
    printf(" read of DIO bits 0-7 = %02hhX\n", inputData);

    apci_read8(fd, 1, BAR_REGISTER, 1, &inputData);
    printf(" read of DIO bits 8-15 = %02hhX\n", inputData);

    apci_read8(fd, 1, BAR_REGISTER, 2, &inputData);
    printf(" read of DIO bits 16-24 = %02hhX\n", inputData);

    printf("Done. Exiting\n");
    terminated = 1;
    apci_cancel_irq(fd, 1);
    pthread_cancel(worker_thread);
err_out:
    close(fd);

    return 0;
}